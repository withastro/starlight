import type { AstroBuiltinAttributes } from 'astro';
import type { HTMLAttributes } from 'astro/types';
import { z } from 'astro/zod';
import { I18nBadgeConfigSchema, type I18nBadgeUserConfig } from './badge';
import { stripLeadingAndTrailingSlashes } from '../utils/path';

interface SidebarBaseUserConfig {
	/** The visible label for this item in the sidebar. */
	label: string;
	/** Translations of the `label` for each supported language. */
	translations?: Record<string, string> | undefined;
	/** Adds a badge to the item */
	badge?: I18nBadgeUserConfig;
}

const SidebarBaseSchema = z.object({
	label: z.string(),
	translations: z.record(z.string()).default({}),
	badge: I18nBadgeConfigSchema(),
});

interface SidebarGroupUserConfig extends SidebarBaseUserConfig {
	/**
	 * Explicitly prevent custom attributes on groups as the final type for supported sidebar item
	 * is a non-discriminated union where TypeScript will not perform excess property checks.
	 * This means that a user could define a sidebar group with custom attributes, not getting a
	 * TypeScript error, and only have it fail at runtime.
	 * @see https://github.com/microsoft/TypeScript/issues/20863
	 */
	attrs?: never;
	/** Whether this item should be collapsed by default. */
	collapsed?: boolean | undefined;
}

const SidebarGroupSchema = SidebarBaseSchema.extend({
	attrs: z.never().optional(),
	collapsed: z.boolean().default(false),
});

// HTML attributes that can be added to an anchor element, validated as
// `Record<string, string | number | boolean | undefined>` but typed as `HTMLAttributes<'a'>`
// for user convenience.
const linkHTMLAttributesSchema = z.record(
	z.union([z.string(), z.number(), z.boolean(), z.undefined(), z.null()])
) as z.Schema<Omit<HTMLAttributes<'a'>, keyof AstroBuiltinAttributes | 'children'>>;
export type LinkHTMLAttributes = z.infer<typeof linkHTMLAttributesSchema>;

export const SidebarLinkItemHTMLAttributesSchema = () => linkHTMLAttributesSchema.default({});

interface SidebarLinkItemUserConfig extends SidebarBaseUserConfig {
	/** The link to this item’s content. Can be a relative link to local files or the full URL of an external page. */
	link: string;
	/** HTML attributes to add to the link item. */
	attrs?: LinkHTMLAttributes | undefined;
}

const SidebarLinkItemSchema = SidebarBaseSchema.extend({
	link: z.string(),
	attrs: SidebarLinkItemHTMLAttributesSchema(),
}).strict();
export type SidebarLinkItem = z.infer<typeof SidebarLinkItemSchema>;

interface AutoSidebarGroupUserConfig extends SidebarGroupUserConfig {
	/** Enable autogenerating a sidebar category from a specific docs directory. */
	autogenerate: {
		/** The directory to generate sidebar items for. */
		directory: string;
		/**
		 * Whether the autogenerated subgroups should be collapsed by default.
		 * Defaults to the `AutoSidebarGroup` `collapsed` value.
		 */
		collapsed?: boolean | undefined;
		/** HTML attributes to add to the autogenerated link items. */
		attrs?: LinkHTMLAttributes | undefined;
		// TODO: not supported by Docusaurus but would be good to have
		/** How many directories deep to include from this directory in the sidebar. Default: `Infinity`. */
		// depth?: number | undefined;
	};
}

const AutoSidebarGroupSchema = SidebarGroupSchema.extend({
	autogenerate: z.object({
		directory: z.string().transform(stripLeadingAndTrailingSlashes),
		collapsed: z.boolean().optional(),
		attrs: SidebarLinkItemHTMLAttributesSchema(),
	}),
}).strict();
export type AutoSidebarGroup = z.infer<typeof AutoSidebarGroupSchema>;

type ManualSidebarGroupInput = z.input<typeof SidebarGroupSchema> & {
	/** Array of links and subcategories to display in this category. */
	items: Array<
		| z.input<typeof SidebarLinkItemSchema>
		| z.input<typeof AutoSidebarGroupSchema>
		| z.input<typeof InternalSidebarLinkItemSchema>
		| z.input<typeof InternalSidebarLinkItemShorthandSchema>
		| ManualSidebarGroupInput
	>;
};

type ManualSidebarGroupOutput = z.output<typeof SidebarGroupSchema> & {
	/** Array of links and subcategories to display in this category. */
	items: Array<
		| z.output<typeof SidebarLinkItemSchema>
		| z.output<typeof AutoSidebarGroupSchema>
		| z.output<typeof InternalSidebarLinkItemSchema>
		| z.output<typeof InternalSidebarLinkItemShorthandSchema>
		| ManualSidebarGroupOutput
	>;
};

type ManualSidebarGroupUserConfig = SidebarGroupUserConfig & {
	/** Array of links and subcategories to display in this category. */
	items: SidebarItemUserConfig[];
};

const ManualSidebarGroupSchema: z.ZodType<
	ManualSidebarGroupOutput,
	z.ZodTypeDef,
	ManualSidebarGroupInput
> = SidebarGroupSchema.extend({
	/** Array of links and subcategories to display in this category. */
	items: z.lazy(() =>
		z
			.union([
				SidebarLinkItemSchema,
				ManualSidebarGroupSchema,
				AutoSidebarGroupSchema,
				InternalSidebarLinkItemSchema,
				InternalSidebarLinkItemShorthandSchema,
			])
			.array()
	),
}).strict();

interface InternalSidebarLinkItemUserConfig extends Omit<SidebarBaseUserConfig, 'label'> {
	/** The visible label for this item in the sidebar. */
	label?: SidebarBaseUserConfig['label'];
	/** The link to this item’s content. Must be a slug of a Content Collection entry. */
	slug: string;
	/** HTML attributes to add to the link item. */
	attrs?: LinkHTMLAttributes | undefined;
}

const InternalSidebarLinkItemSchema = SidebarBaseSchema.partial({ label: true }).extend({
	slug: z.string(),
	attrs: SidebarLinkItemHTMLAttributesSchema(),
});

type InternalSidebarLinkItemShorthandUserConfig = string;

const InternalSidebarLinkItemShorthandSchema = z
	.string()
	.transform((slug) => InternalSidebarLinkItemSchema.parse({ slug }));
export type InternalSidebarLinkItem = z.output<typeof InternalSidebarLinkItemSchema>;

export type SidebarItemUserConfig =
	| SidebarLinkItemUserConfig
	| ManualSidebarGroupUserConfig
	| AutoSidebarGroupUserConfig
	| InternalSidebarLinkItemUserConfig
	| InternalSidebarLinkItemShorthandUserConfig;

export const SidebarItemSchema = z.union([
	SidebarLinkItemSchema,
	ManualSidebarGroupSchema,
	AutoSidebarGroupSchema,
	InternalSidebarLinkItemSchema,
	InternalSidebarLinkItemShorthandSchema,
]);
export type SidebarItem = z.infer<typeof SidebarItemSchema>;
