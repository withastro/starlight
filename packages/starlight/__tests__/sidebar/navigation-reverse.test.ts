import { describe, expect, test, vi } from 'vitest';
import { getSidebarFromConfig } from '../../utils/navigation';
import type { SidebarGroup } from '../../utils/routing/types';
import type { StarlightConfig } from '../../utils/user-config';

vi.mock('astro:content', async () =>
	(await import('../test-utils')).mockedAstroContent({
		docs: [
			['guides/one.md', { title: 'One', sidebar: { order: 1 } }],
			['guides/two.md', { title: 'Two', sidebar: { order: 2 } }],
			['guides/three.md', { title: 'Three', sidebar: { order: 3 } }],
			['guides/sub/child-a.md', { title: 'Child A', sidebar: { order: 1 } }],
			['guides/sub/child-b.md', { title: 'Child B', sidebar: { order: 2 } }],
		],
	})
);

const sidebarConfig = [
	{ label: 'Guides (default)', translations: {}, autogenerate: { directory: 'guides' } },
	{
		label: 'Guides (reversed)',
		translations: {},
		autogenerate: { directory: 'guides', reverse: true },
	},
] satisfies NonNullable<StarlightConfig['sidebar']>;

function summarizeGroup(group: SidebarGroup) {
	return group.entries.map((entry) =>
		entry.type === 'group'
			? { type: entry.type, label: entry.label, entries: entry.entries.map((child) => child.label) }
			: { type: entry.type, label: entry.label }
	);
}

describe('autogenerated sidebar reverse option', () => {
	test('reverses ordering for generated groups', () => {
		const sidebar = getSidebarFromConfig(sidebarConfig, '/guides/three/', undefined);
		const defaultGroup = sidebar.find(
			(entry): entry is SidebarGroup => entry.type === 'group' && entry.label === 'Guides (default)'
		);
		const reversedGroup = sidebar.find(
			(entry): entry is SidebarGroup => entry.type === 'group' && entry.label === 'Guides (reversed)'
		);

		expect(defaultGroup).toBeDefined();
		expect(reversedGroup).toBeDefined();

		expect(summarizeGroup(defaultGroup!)).toEqual([
			{ type: 'link', label: 'One' },
			{ type: 'group', label: 'sub', entries: ['Child A', 'Child B'] },
			{ type: 'link', label: 'Two' },
			{ type: 'link', label: 'Three' },
		]);

		expect(summarizeGroup(reversedGroup!)).toEqual([
			{ type: 'link', label: 'Three' },
			{ type: 'link', label: 'Two' },
			{ type: 'group', label: 'sub', entries: ['Child B', 'Child A'] },
			{ type: 'link', label: 'One' },
		]);

		reversedGroup!.entries.forEach((entry) => {
			if (entry.type === 'link') {
				expect(entry).toHaveProperty('isCurrent');
			}
		});
	});
});
